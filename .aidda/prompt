Mime-Version: 1.0
Content-Transfer-Encoding: quoted-printable
In: /home/stevegt/lab/promisegrid/promisegrid/README.md, 
    v2/message.go,
    v2/TODO.md,
    v2/DESIGN.md,
    v2/cache.go,
    v2/kernel.go,
    v2/go.mod,
    v2/module.go,
    v2/server.go,
    v2/context.md,
    v2/message_test.go,
    v2/ADVICE.md,
    v2/testdata/hello.msg
XOut: v2/cmd/grid-cli/main.go,
    v2/message.go,
    v2/kernel.go,
    v2/module.go,
    v2/server.go
XOut: v2/message_test.go, v2/testdata/hello.msg,
    v2/message.go,
    v2/kernel.go,
    v2/server.go
XOut: v2/module.go,
XOut: v2/cache.go 
XOut: v2/DESIGN.md
XOut: v2/TODO.md
XOut: v2/ADVICE.md
Out: v2/DISCUSS.md

It sounds like a cache node struct might include a field that marks
or flags the node as being an executable, an argument, or a result.  Is
that correct?  Or do we simply store the node's sequence number in
that field, i.e. the node's position in the received message?  Oh
wait, the cache stores messages intact, so the cache index tree is
built from the message's positional parameters, starting with the
first parameter in position zero, which we've been calling the
promise hash.  It appears that the cache actually knows very little
about protocols, promises, or anything else other than the positional
parameters of the message.  The cache is a simple nested key-value
store.  The value is the message, and the key is the message's
parameters.  But then how do we know when we need to load a module
from the cache, execute it, and store the result back in the cache?

As far as permissions and capabilities go, we might have a situation
where a cache key or value is encrypted, and the cache node is 
unlocked by a capability.  This would be a way to implement a
capability-based security model.  The capability would be a key
that is used by the kernel to unlock the cache node.  Alternatively,
the kernel knows nothing about capabilities, and it is up to modules
to verify that the caller has the necessary permissions to access
a resource.  This would be a more traditional capability model, where
the capability is a token that is passed to the module, and the module
verifies the token before granting access to the resource.  



Discuss all of this in the DISCUSS.md file.  
