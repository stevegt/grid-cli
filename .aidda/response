Here are the merged files:

File: /home/stevegt/lab/grid-cli/v2/doc/221-graph.md
```
# Sequence Matching Graph for PromiseGrid

## Overview

The sequence-matching graph in PromiseGrid is a data structure used to match input sequences to stored sequences by traversing nodes and edges efficiently. Each node and edge in the sequence-matching graph has specific compositions that facilitate efficient sequence matching and completion.

## Node Composition

Each node in the sequence-matching graph contains the following components:

1. **Label**:
    - A string representing the segment of the sequence at this node.
2. **Occurrences**:
    - A list of positions in the reference sequences where this segment occurs.
3. **Children**:
    - A map from sequence characters to child nodes, representing the continuation of the sequence.

```go
type Node struct {
    Label      string
    Occurrences []int
    Children   map[rune]*Node
}
```

## Edge Composition

Each edge in the sequence-matching graph connects to a child node and represents the next segment in the sequence.

1. **Character**:
    - The character from the parent node's label to this edge.
2. **ChildNode**:
    - Reference to the child node.

```go
type Edge struct {
    Character  rune
    ChildNode *Node
}
```

## Example Structure

Consider a simplified example with "ACGT" and "AGT" sequences:

```plaintext
       (root)
       /   \
      A     A
     /       \
    C         G
     \         \
      G         T
       \
        T
```

## Input Sequence Matching

To match an input sequence to stored sequences in a sequence-matching graph, follow these steps:

1. **Traversal**: Starting from the root, traverse through the graph using the characters of the input sequence.
2. **Edge Matching**: At each node, follow the edge that matches the next character of the input sequence.
3. **Match Determination**: If a suitable edge or child node cannot be found at any point, the matching process terminates without a match.

## Graph Traversal Mechanism

Graph traversal utilizes either a recursive or an iterative technique to explore nodes and edges.

### Recursive Method

```go
func MatchSequence(node *Node, sequence string, index int) bool {
    if index == len(sequence) {
        return true
    }
    char := rune(sequence[index])
    if child, ok := node.Children[char]; ok {
        return MatchSequence(child, sequence, index+1)
    }
    return false
}
```

### Iterative Method

```go
func MatchSequenceIterative(root *Node, sequence string) bool {
    currentNode := root
    for _, char := range sequence {
        if child, ok := currentNode.Children[char]; ok {
            currentNode = child
        } else {
            return false
        }
    }
    return true
}
```

## Examples of Matching

1. **Example 1: Matching "ACGT"**
    - Starting from the root, traverse edges labeled 'A', 'C', 'G', and 'T'.
    - Successful match if all edges are followed correctly.

2. **Example 2: Matching "AGT"**
    - Starting from the root, traverse edges labeled 'A', 'G', and 'T'.
    - Successful match if all edges are followed correctly.

## Advanced Questions Answered

### Sequence-Matching Graph and 'Children' Field

In a sequence-matching graph, does the 'Children' field of a node contain the next node in the sequence? Or does it contain both previous and next nodes?

- The 'Children' field of a node contains only the next node(s) in the sequence. It maps sequence characters to their corresponding child nodes, representing the continuation of the sequence.

### Genome Storage in Graph

Are entire genomes stored in the graph? Or are only the sequences of interest stored? If the latter, how are the sequences of interest identified? Are they identified by their position in the genome? Or are they identified by some other means?

- Only the sequences of interest are stored in the graph. These sequences are identified based on specific criteria such as the presence of particular motifs or functional relevance. The identification can be based on their positions in the genome or other biological markers.

### Adding a New Sequence

Show an example of how a new sequence is added to the graph.

```go
func AddSequence(root *Node, sequence string) {
    currentNode := root
    for _, char := range sequence {
        if _, ok := currentNode.Children[char]; !ok {
            newNode := &Node{
                Label:      string(char),
                Occurrences: []int{},
                Children:   make(map[rune]*Node),
            }
            currentNode.Children[char] = newNode
        }
        currentNode = currentNode.Children[char]
    }
    // Optionally add occurrence position if needed
    // currentNode.Occurrences = append(currentNode.Occurrences, position)
}

// Example usage:
root := &Node{Children: make(map[rune]*Node)}
AddSequence(root, "AGC")
```

### Conclusion

The sequence-matching graph structure, with detailed node and edge compositions, a traversal mechanism, and illustrative examples, forms the core of efficient sequence matching. This approach supports both recursive and iterative traversal techniques, ensuring flexibility and clarity in matching input sequences to stored reference sequences. This documentation integrates theoretical foundations with practical implementation methods to provide a cohesive understanding of sequence-matching graphs in the PromiseGrid system.

## Optimizations and Further Research

### Sequence Matching with Unknown Leading Characters

To match a sequence fragment with unknown leading characters, the system can:
1. **Segment the Fragment**: Divide the input sequence fragment into smaller overlapping segments.
2. **Search for Segments**: Locate nodes corresponding to the segments within the graph.
3. **Extend Matches**: Extend partial matches by traversing adjacent nodes in the graph till a complete match is found.

### Practical Example with Unknown Leading Characters

Consider an input fragment "CGTA":
1. **Segment**: Break down "CGTA" into "CGT", "GTA".
2. **Search**: Find nodes corresponding to "CGT" and "GTA" in the graph.
3. **Extend**: Extend matches by exploring neighboring nodes to form the complete sequence.

In this way, PromiseGrid effectively handles sequence fragments with unknown leading characters, ensuring robust sequence matching capabilities.

## Capability Tokens and Prior Art

### Self-Contained Capability Tokens

A capability token can be crafted to be self-contained and self-describing by including both the permissions granted and the identity of the party to whom the permission is granted. This design ensures that the token itself carries all the information needed to understand the scope and target of the permissions without needing to reference external data.

### How It Works

1. **Structure**: The structure of such a self-contained capability token typically includes fields for:
   - **Identity of the Holder**: Information about the entity that holds the token.
   - **Permissions**: Details about what actions the holder is permitted to perform.
   - **Issuerâ€™s Identity**: Information about the entity that issued the token.
   - **Signature**: Cryptographic signature from the issuer to ensure integrity and authenticity.

2. **Encoding**: The token can be encoded in a standardized format such as JSON Web Tokens (JWT) which supports custom claims to include the necessary fields.

3. **Verification**: When the token is presented, the system:
   - Verifies the cryptographic signature to ensure the token was indeed issued by the trusted party.
   - Checks the permissions described within the token.
   - Confirms the identity of the holder matches the intended recipient.

Several systems and frameworks implement self-contained capability tokens:

1. **Macaroons**: These are flexible authorization credentials that support delegation and attenuation. A macaroon is a bearer token that can encapsulate permissions and is augmented with caveats, which are conditions that must be satisfied for the macaroon to be considered valid.
2. **JSON Web Tokens (JWT)**: JWTs are widely used in web applications to assert claims between parties. They can include custom claims to specify permissions and the intended audience. A JWT can be signed to ensure authenticity and integrity.
3. **Caveats in Capability-Based Systems**: Traditional capability-based security systems sometimes support a form of caveats or restrictions within the tokens themselves to specify the scope of permissions and the authorized user.

### Recommendations

1. **Design Tokens Carefully**: Ensure that the structure of the tokens balances comprehensiveness with simplicity. Include necessary fields for permissions, identity, and signatures.
   
2. **Use Standard Formats**: Leverage existing standards like JWTs for encoding tokens to benefit from existing libraries and tools for creation, parsing, and verification.

3. **Cryptographic Security**: Ensure that tokens are signed using robust cryptographic methods to prevent forgery and tampering.

4. **Revocation**: Implement mechanisms to handle token revocation in case permissions need to be rescinded before the token naturally expires.

### Discussion on the Leading Hash in Messages

In the PromiseGrid Kernel, messages MAY start with a promise hash followed by a module hash, and then additional arguments. This structure allows receivers to filter messages based on promises they are willing to accept and route the message to the appropriate module. Here are the pros and cons of the promise hash coming first:

**Pros:**
- **Enhanced Filtering**: Placing the promise hash first allows modules and nodes to quickly filter messages based on the promises they accept.
- **Trust and Governance**: This aligns with decentralized governance. Nodes can establish trust relationships by agreeing on specific promises they will accept.
- **Modular Routing**: Early identification of the promise allows the kernel to route messages to the appropriate module, ensuring efficient distributed handling.

### Kernel's Dynamic Handling of Accept and HandleMessage

Implementing an advanced interaction model involves considering different versions of function handling of messages. There are two possible structures: combined functions or separate functions.

### Combined Function:

```go
type Module interface {
    ProcessMessage(ctx context.Context, parms ...interface{}) (Message, error)
}

type LocalCacheModule struct {
    cacheDir string
}

func NewLocalCacheModule(cacheDir string) *LocalCacheModule {
    return &LocalCacheModule{cacheDir: cacheDir}
}

func (m *LocalCacheModule) ProcessMessage(ctx context.Context, parms ...interface{}) (Message, error) {
    // Implement logic to process message, which includes accepting and handling
    // Return a promise message with acceptance and handling results or errors
}
```

### Separate Functions:

```go
type Module interface {
    Accept(ctx context.Context, parms ...interface{}) (Message, error)
    HandleMessage(ctx context.Context, parms ...interface{}) ([]byte, error)
}

type LocalCacheModule struct {
    cacheDir string
}

func NewLocalCacheModule(cacheDir string) *LocalCacheModule {
    return &LocalCacheModule{cacheDir: cacheDir}
}

func (m *LocalCacheModule) Accept(ctx context.Context, parms ...interface{}) (Message, error) {
   // Implement logic for accepting or rejecting based on parameters
}

func (m *LocalCacheModule) HandleMessage(ctx context.Context, parms ...interface{}) ([]byte, error) {
    // Implement logic for handling the message after acceptance
}
```

### Conclusion

By integrating promises at every level and implementing a hierarchical syscall tree with caching and acceptance history, PromiseGrid ensures trust, accountability, and efficient message handling in a decentralized governance framework. The simplified message structure and consistent handling of cache and modules contribute to a robust and flexible system.

### Importance of Including Module Hash in Messages for Deterministic Execution and Demand-Driven Deployment of New Code

Including the hash of the module to be executed in the message is crucial for achieving deterministic execution and facilitating demand-driven deployment of new code in decentralized systems. Here are key reasons why this practice is recommended:

1. **Deterministic Execution**:
   Including the module hash in the message ensures that the same piece of code is executed consistently across different nodes. This deterministic behavior is essential for maintaining consistency and correctness in distributed systems. By specifying the exact module to be run, all nodes can reliably and repeatably execute the same logic, avoiding differences in behavior due to variations in module versions or implementations.

2. **Content-Addressable Code**:
   The module hash serves as a unique identifier for the specific version of the code to be executed. This content-addressable storage mechanism ensures that the precise code is located and executed, eliminating ambiguity. Nodes can fetch the exact module specified by the hash, even if new versions or updates are available, ensuring backward compatibility and preventing unexpected changes in system behavior.

3. **Demand-Driven Deployment**:
   By including the module hash in the message, new code can be deployed on-demand. Nodes that do not have the required module can fetch it dynamically based on the hash, allowing for seamless updates and scaling. This demand-driven deployment model ensures that nodes always execute the latest or specified version of the module, promoting flexibility and ease of maintenance in decentralized environments.

4. **Security and Trust**:
   The module hash provides a way to verify the integrity and authenticity of the code being executed. Nodes can validate the fetched module against the specified hash, ensuring that the code has not been tampered with. This practice builds trust among nodes, as they can rely on the exact code promised in the message without the risk of executing malicious or unauthorized code.

5. **Enabling Capabilities**:
   Including module hashes in messages aligns with the capability-based security model. Capabilities can include specific module hashes that nodes are authorized to execute, providing fine-grained access control. This approach ensures that nodes only execute permitted code, enhancing the overall security and governance of the decentralized system.

In summary, including the module hash in messages is essential for achieving deterministic execution, enabling content-addressable storage, facilitating demand-driven deployment of new code, ensuring security, and supporting capability-based access control. This practice aligns with the principles of decentralized systems, promoting consistency, flexibility, and trust among participating nodes.

### JSON Web Tokens (JWT) 

JWTs are typically encoded using Base64url, which is a URL-safe variant of Base64 encoding.

#### Why Base64url?

1. **URL-safe**: Base64url encoding replaces characters that are not URL-safe (such as `+`, `/`, and `=`) with URL-safe alternatives (`-`, `_`, and no padding). This ensures that the token can be safely included in a URL without requiring additional encoding.
2. **Human-readable**: While not as compact as some other encodings (like base58), Base64url maintains a balance between human readability and URL safety.
3. **Standardized**: The use of Base64url for JWTs is specified in the JSON Web Token (JWT) specification (RFC 7519). This standardization means that the approach is widely supported and understood, making it interoperable across different systems and libraries.

#### Encoding Steps

1. **Header and Payload**: The JWT consists of three parts: the header, the payload, and the signature. Each part is encoded separately using Base64url.
2. **Concatenation**: The three parts are concatenated together with periods (`.`) as separators. This forms the final JWT string that can be included in a URL.

#### Example

Suppose you have the following JWT:
```json
{
  "header": {
    "alg": "HS256",
    "typ": "JWT"
  },
  "payload": {
    "sub": "1234567890",
    "name": "John Doe",
    "iat": 1516239022
  },
  "signature": "SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
}
```

The encoded JWT would look something like this:
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

This encoded JWT can be safely used as a URL parameter without further encoding.

Using the standard Base64url encoding for JWTs in URLs ensures compatibility with existing libraries and tools, making it a reliable choice for encoding JWT tokens for use in web applications.

### Open Questions

1. **Handling Broken Promises**: What strategies can we implement to handle broken promises effectively? How can we ensure that nodes that consistently break promises have their reputation impacted in a measurable way?
2. **Determining Best Route**: When multiple handlers are available, how can we determine the most efficient or reliable route for handling a message? Should we prioritize handlers based on historical performance, reputation, or other factors?
3. **Integration with Other Systems**: How can we better integrate JSON Web Tokens (JWT) and similar systems with PromiseGridâ€™s architecture? What role should JWT play in managing capabilities within the grid?
4. **Security Measures**: Given the reliance on module hashes for deterministic execution, what additional security measures can enhance the integrity and trustworthiness of the system? How can we mitigate potential risks associated with hash collisions and tampering? 

```
EOF_/home/stevegt/lab/grid-cli/v2/doc/221-graph.md
```
EOF_/home/stevegt/lab/grid-cli/v2/doc/221-graph.md