File: /home/stevegt/lab/grid-cli/v2/doc/002-design.md
```
# PromiseGrid Design

## Overview

PromiseGrid is designed as a decentralized computing, communications, and governance framework, leveraging promise-based interactions and content-addressable storage to create a robust and modular system.

## Core Concepts

1. **Decentralized Architecture**: PromiseGrid operates as a decentralized computing, communications, and governance system. It is designed to be owned and operated by its users rather than any single entity.

2. **Capability-as-Promise Model**: Capabilities are treated as promises, similar to the concepts from Promise Theory. A capability token represents a promise that can either be fulfilled or revoked.

3. **Content-addressable Code**: Both code and data are addressed by their content, not by location or name. This allows the grid to store and execute code and access data from any node in the network.

4. **Promises All the Way Down**: Every interaction in the system is based on promises. A response to a promise is another promise.

5. **Non-Sandboxed Modules**: Non-sandboxed modules in PromiseGrid are analogous to device drivers in a microkernel OS. Just as device drivers handle specific hardware functionality in a microkernel, non-sandboxed modules handle specific external operations in the grid (e.g., network communications, file access). The kernel delegates these operations to non-sandboxed modules while maintaining control over the overall execution.

## Glossary of Terms and Concepts

- **Decentralized Architecture**: A system design where control is distributed among various actors or nodes, rather than centralized in a single entity.
- **Capability-as-Promise Model**: A model where capabilities represent promises that can either be fulfilled or revoked.
- **Content-addressable Code**: Code and data addressed based on their content, allowing decentralized storage and execution.
- **Promises All the Way Down**: A paradigm where every interaction in the system results in a promise, with responses being new promises.
- **Non-Sandboxed Modules**: Modules granted more access and responsibility, analogous to device drivers, for handling specific external operations.

## Flexible Design for Module Registration

### Overview

Modules in PromiseGrid interface with the kernel via explicit registration or through hash-based routing mechanisms. These two primary methods offer distinct advantages and challenges:

### Explicit Module Registration

#### Pros
1. **Clarity and Explicitness**: Modules report their capabilities, simplifying system understanding and management.
2. **Fine-Grained Control**: The kernel can enforce rules and constraints based on module capabilities.
3. **Dynamic Adaptation**: Modules can update their capabilities dynamically, supporting on-the-fly changes.

#### Cons
1. **Complexity**: Adds complexity to module initialization and management.
2. **Performance Overhead**: Maintaining and querying a registry introduces overhead.
3. **Dependency Management**: Changes in capabilities may necessitate updates across the system, increasing dependency risks.

### Exchange Rate Routing

### Concept

Exchange rate routing is an innovative mechanism where hosts within the grid route messages based on the exchange rates of personal currencies. Each host acts like its own "central bank," issuing a form of currency represented by reputation points. These reputation points influence the routing decisions, promoting reliable behavior and network stability.

### How It Works

1. **Currency Evaluation**: Each host evaluates the currency (reputation) of other hosts.
2. **Routing Decisions**: Hosts prefer routes through other hosts with higher-valued currencies to ensure stability and reliability.
3. **Dynamic Adjustments**: Exchange rates are dynamic and adjust based on host behavior and market conditions.

### Advantages

- **Encourages Reliability**: Hosts are incentivized to maintain strong reputations.
- **Economic Incentives**: The system uses market dynamics, encouraging decentralized control.
- **Self-Regulating**: Misbehaving hosts receive less traffic, reducing their ability to affect the network adversely.

### Hash-Based Module Routing

#### Pros
1. **Simplicity**: Cryptographic hashes guide message routing, eliminating explicit registration.
2. **Efficiency**: Highly efficient due to unique and consistent addressing.
3. **Decentralized Management**: Modules are self-contained, facilitating independent management.

#### Cons
1. **Opaque Mapping**: Harder to identify which module handles a message without clear declarations.
2. **Limited Flexibility**: Dynamic updates require hash changes, reducing adaptability.
3. **Security Risks**: Must mitigate risks like hash collisions and attacks.

### Combining Both Approaches

A hybrid approach leverages the strengths of both explicit registration and hash-based routing:

1. **Initialization Phase**: Modules register their capabilities during initialization.
2. **Hash-Based Execution**: Runtime routing employs cryptographic hashes, consulting the registry as needed.

### Nested Messages and Kernel Arbitration

Modules can unwrap nested messages, allowing dynamic and complex interactions. The kernel's arbitration is not final, supporting a modular design where tasks can be delegated further through nested messaging.

#### Implications
1. **Delegated Control**: Enables modular and extensible system design by delegating tasks.
2. **Dynamic Message Flows**: Supports flexible message handling based on context.
3. **Complex Dependency Graphs**: Requires careful management to maintain stability.

- XXX third alternative -- byte sequence completion 

### Conclusion

Explicit registration and hash-based routing methods impact system design and functionality significantly. Combining both approaches balances their strengths, enhancing modularity, adaptability, and efficiency. This flexibility, including nested messaging, bolsters PromiseGrid's modular architecture.

## Cache (Syscall Tree) Node Structure - The Ant-Routing Mechanism

XXX describe  trie-based routing

### Messages and Promises

1. **Message Structure**:

XXX messages are byte sequences that have no meaning to the kernel,
only modules


### Multihash, Multibase, and Multicodec

PromiseGrid leverages multihash and multibase to autodetect hash formats, enhancing compatibility and extensibility across various data formats.

### Conclusion


### Open Questions

- XXX reconcile byte sequence completion with explicit registration and hash-based routing

- Mechanisms to handle broken promises effectively?
- Determining the best route with multiple handlers?

## Suggestions for Improving this Document

- Add more examples and case studies.
- Expand on hierarchical syscall tree descriptions.
- Update sections with new questions arising during implementation.
- Refine glossary with specialized terms and concepts.
- Incorporate visual aids to showcase system architecture and data flow.
```
EOF_/home/stevegt/lab/grid-cli/v2/doc/002-design.md
